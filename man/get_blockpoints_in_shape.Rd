% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_blockpoints_in_shape.R
\name{get_blockpoints_in_shape}
\alias{get_blockpoints_in_shape}
\alias{shapefile2blockpoints}
\title{Find all Census blocks in a polygon, using internal point of block}
\usage{
get_blockpoints_in_shape(
  polys,
  addedbuffermiles = 0,
  blocksnearby = NULL,
  dissolved = FALSE,
  safety_margin_ratio = 1.1,
  crs = 4269,
  updateProgress = NULL
)
}
\arguments{
\item{polys}{Spatial data as from sf::st_as_sf(), with
points as from \code{\link[=shapefile_from_sitepoints]{shapefile_from_sitepoints()}},
or a table of points with lat,lon columns that will first be converted here using that function,
or polygons}

\item{addedbuffermiles}{width of optional buffering to add to the points (or edges), in miles}

\item{blocksnearby}{optional table of blocks with blockid, etc (from which lat,lon can be looked up in blockpoints dt)}

\item{dissolved}{If TRUE, use sf::st_union(polys) to find unique blocks inside any one or more of polys}

\item{safety_margin_ratio}{multiplied by addedbuffermiles, how far to search for
blocks nearby using getblocksnearby(), before using those found to do the intersection via sf::}

\item{crs}{used in st_as_sf() and st_transform() and shape_buffered_from_shapefile_points(), crs = 4269 or Geodetic CRS NAD83}

\item{updateProgress}{optional Shiny progress bar to update}
}
\value{
Block points table for those blocks whose internal point is inside the buffer
which is just a circular buffer of specified radius if polys are just points.
}
\description{
Like \code{\link[=getblocksnearby]{getblocksnearby()}}, but for blocks in each polygon rather than
blocks near each facility. For analyzing all residents in certain zones
such as places at elevated risk, redlined areas, watersheds, etc.
}
\details{
This uses getblocksnearby() to get a very fast rough/good estimate of
which US block points are nearby (with a safety margin - see param below),
before then using sf:: to carefully identify which of those candidate blocks are actually
inside each polygon (e.g., circle) according to sf:: methods.

For circular buffers, just using getblocksnearby() should work and not need this function.

For noncircular polygons, buffered or not, this function will provide a way to very quickly
filter down to which of the millions of US blocks should be examined by the sf:: join / intersect,
since otherwise it takes forever for sf:: to check all US blocks.
}
\examples{
  # y <- get_blockpoints_in_shape()

  # x = shapefile_from_sitepoints(testpoints_n(2))
  # y = get_blockpoints_in_shape(x, 1)  # very very slow
}
\seealso{
\code{\link[=get_blockpoints_in_shape]{get_blockpoints_in_shape()}} \code{\link[=shapefile_from_sitepoints]{shapefile_from_sitepoints()}} \code{\link[=shape_buffered_from_shapefile_points]{shape_buffered_from_shapefile_points()}}
}
